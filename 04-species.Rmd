# Species

## Mapping the location of species

Let's take a look at the location of species. To do this we will query plot level NASIS data using the query outlined in [Accessing plot level vegetation data](#plotveg).

Once you have queried, you can filter your dataset for any species of interest. I am going to search for a genus - *Artemisia* (sagebrush). Ultimately, we will produce a map that shows the distribution of all the species of *Artemisia*. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
veg_data <- fetchVegdata(dsn = "C:/Users/Nathan.Roe/Documents/SEKI/CA792_veg.sqlite", SS = FALSE)
```

```{r}
veg_data <- fetchVegdata(dsn = "C:/Users/Nathan.Roe/Documents/SEKI/CA792_veg.sqlite", SS = FALSE)

artemesia_df <-
  veg_data$vegplotspecies %>% filter(plantsciname %in% str_subset(veg_data$vegplotspecies$plantsciname, "Artemisia")) %>%
  select(siteiid, plantsciname)
```

Query for *Artemisia* and create a spatial dataframe with coordinates 
```{r}
artemesia_df <-
  veg_data$vegplotspecies %>% filter(plantsciname %in% str_subset(veg_data$vegplotspecies$plantsciname, "Artemisia")) %>%
  select(siteiid, plantsciname)

artemesia_location <-
  veg_data$vegplotlocation %>% dplyr::filter(siteiid %in% artemesia_df$siteiid) %>% select(siteiid, utmzone, utmeasting, utmnorthing) %>%
  dplyr::left_join(artemesia_df) %>% st_as_sf(coords = c('utmeasting', 'utmnorthing'),
                                              crs = st_crs(32611))
```

Create a list of dataframes based on the different 



```{r}
veg_data <- fetchVegdata(dsn = "C:/Users/Nathan.Roe/Documents/SEKI/CA792_veg.sqlite", SS = FALSE)

artemesia_df <-
  veg_data$vegplotspecies %>% filter(plantsciname %in% str_subset(veg_data$vegplotspecies$plantsciname, "Artemisia")) %>%
  select(siteiid, plantsciname)

artemesia_location <-
  veg_data$vegplotlocation %>% dplyr::filter(siteiid %in% artemesia_df$siteiid) %>% select(siteiid, utmzone, utmeasting, utmnorthing) %>%
  dplyr::left_join(artemesia_df) %>% st_as_sf(coords = c('utmeasting', 'utmnorthing'),
                                              crs = st_crs(32611))

artemesia_location_split <-  split(artemesia_location, artemesia_location$plantsciname)


my_colors <- RColorBrewer::brewer.pal(n = length(artemesia_location_split), name = 'Set1')


mapview::mapView(artemesia_location_split, col.regions = my_colors)
```






It can be really useful to create a stored version of your selected set. That way, if you are frequently changing between different different selected sets, you do not have to clear your selected set and run a new query. This can be done by saving your selected set as an SQlite database. This allows you to call the saved SQlite database in SoilDB functions.

Let's look at how we can create a stored SQlite database. 

```{r, eval=FALSE}
soilDB::createStaticNASIS(SS = TRUE, tables = 
      soilDB::get_NASIS_table_name_by_purpose(c("area", "legend", "mapunit", "datamapunit", "component", "metadata", "lookup", "nasis")),
      output_path = "C:/Users/Nathan.Roe/Documents/SEKI/CA792_veg.sqlite")
```

Note: The tables listed in the get_NASIS_table_name_by_purpose argument should cover the majority of situations. If you run into an issue, though, soilDB will likely name a specific table that is missing. If that happens, you will have to add the table to the character vector. 

Once you have stored your SQlite database, you can call it using the soilDB functions. The default argument in ```fetchNASIS()``` and other SoilDB functions is ```SS = TRUE```. We are going to change that to false and identify the location of the SQlite database in the dsn argument. 

```{r, eval=FALSE}
my.components.MLRA <- fetchNASIS(from = "components", duplicates = T, dsn = "C:/Users/Nathan.Roe/Documents/SEKI/CA792_veg.sqlite", SS = FALSE)
```

This can be extremely useful when you have multiple selected sets that you are working with. 